import os
from string import Template

import numpy as np
import yaml

from polydispers.input_config import InputConfig
from polydispers.topology_config import TopologyConfig


def write_gro_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by gro_writer",
) -> None:
    """
    Write a GRO format file with simplified inputs.

    Args:
        filename: Output .gro filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string
    """
    n_atoms = len(coordinates)

    with open(filename, "w") as f:
        # Write title line
        f.write(f"{title}\n")

        # Write number of atoms
        f.write(f"{n_atoms}\n")

        # Write atom information
        for i, (x, y, z) in enumerate(coordinates, start=1):
            resid = 1
            atomid = i
            line = f"{resid:>5d}{resname:<5s}{atomname:>5s}{atomid:>5d}"
            line += f"{x:8.3f}{y:8.3f}{z:8.3f}"
            f.write(line + "\n")

        # Write box vectors (cubic box)
        f.write(f"{box_size:10.5f}{box_size:10.5f}{box_size:10.5f}\n")


def write_pdb_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by pdb_writer",
) -> None:
    """
    Write a PDB format file with simplified inputs.

    Args:
        filename: Output .pdb filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string

    PDB Format Reference:
    ATOM/HETATM (1-6)    Record name
    atom number (7-11)    Integer
    atom name (13-16)     Atom name
    alt loc (17)          Alternate location indicator
    residue name (18-20)  Residue name
    chain (22)            Chain identifier
    residue number (23-26) Integer
    x (31-38)            Real(8.3) Orthogonal coordinates for X
    y (39-46)            Real(8.3) Orthogonal coordinates for Y
    z (47-54)            Real(8.3) Orthogonal coordinates for Z
    occupancy (55-60)     Real(6.2)
    temp factor (61-66)   Real(6.2)
    segment id (73-76)    Segment identifier
    element (77-78)       Element symbol
    charge (79-80)        Charge
    """
    # Convert nm to Angstroms for PDB format
    coords_ang = coordinates * 10.0
    box_ang = box_size * 10.0
    resid = 1

    with open(filename, "w") as f:
        # Write title
        f.write(f"TITLE     {title}\n")
        f.write("REMARK    Generated by pdb_writer\n")

        # Write crystal structure (box size)
        # Format: CRYST1   50.000   50.000   50.000  90.00  90.00  90.00 P 1           1
        f.write(f"CRYST1{box_ang:9.3f}{box_ang:9.3f}{box_ang:9.3f}  90.00  90.00  90.00 P 1           1\n")

        # Write atom coordinates
        for i, (x, y, z) in enumerate(coords_ang, start=1):
            # Format each field according to PDB specifications
            record = "ATOM  "  # cols 1-6
            serial = f"{i:5d}"  # cols 7-11
            space1 = " "  # col 12
            atom = f"{atomname:<4s}"  # cols 13-16
            alt_loc = " "  # col 17
            res_name = f"{resname:<3s}"  # cols 18-20
            space2 = " "  # col 21
            chain = "A"  # col 22
            res_seq = f"{resid:4d}"  # cols 23-26
            ins_code = " "  # col 27
            space3 = "   "  # cols 28-30
            x_coord = f"{x:8.3f}"  # cols 31-38
            y_coord = f"{y:8.3f}"  # cols 39-46
            z_coord = f"{z:8.3f}"  # cols 47-54
            occupancy = f"{1.00:6.2f}"  # cols 55-60
            temp_factor = f"{0.00:6.2f}"  # cols 61-66
            space4 = "      "  # cols 67-72
            segment = f"{resname:<4s}"  # cols 73-76
            element = f"{atomname:>2s}"  # cols 77-78
            charge = "  "  # cols 79-80

            line = (
                f"{record}{serial}{space1}{atom}{alt_loc}{res_name}"
                f"{space2}{chain}{res_seq}{ins_code}{space3}"
                f"{x_coord}{y_coord}{z_coord}{occupancy}{temp_factor}"
                f"{space4}{segment}{element}{charge}\n"
            )

            f.write(line)

        # Write END record
        f.write("END\n")


def write_packmol_input(
    output_filename: str, filenames: list[str], box_size: float, output_packmol_filename: str, filetype: str = "xyz"
) -> None:
    with open(output_packmol_filename, "w") as f:
        f.write("tolerance 2.0\n")
        f.write(f"filetype {filetype}\n")
        f.write(f"output {output_filename}\n")
        for filename in filenames:
            f.write(
                f"""
structure {filename}
  number 1
  inside box 0 0 0 {box_size} {box_size} {box_size}
  resnumbers 2
end structure
      """
            )


def write_xyz_file(filename: str, coordinates: np.ndarray, atomname: str = "C") -> None:
    with open(filename, "w") as f:
        f.write(f"{len(coordinates)}\n")
        f.write("Generated by xyz_writer\n")
        for i, (x, y, z) in enumerate(coordinates, start=1):
            f.write(f"{atomname} {x} {y} {z}\n")


def write_topology_file(filename: str, config: InputConfig, num_repeat_units: list[int]) -> None:
    """Generates a topology file for the system.

    Args:
        filename: Output topology filename
        config: Input configuration containing topology and mass information
        num_repeat_units: List of number of repeat units for each chain
    """
    # Write YAML file
    with open(filename, "w+") as out_yaml:
        # Write box size
        out_yaml.write(f"box_size: {config.box_size}\n")

        # Write chain description
        out_yaml.write("chain_description:\n")
        out_yaml.write(f'    repeat_unit_topology: "{config.repeat_unit_topology}"\n')
        out_yaml.write("    chain_lengths: [")
        out_yaml.write(", ".join(map(str, num_repeat_units)))
        out_yaml.write("]\n")

        # Write polymer information
        out_yaml.write("polymer:\n")
        out_yaml.write("    bead_types:\n")
        for bead_type in set(config.repeat_unit_topology):
            out_yaml.write(f"        {bead_type}:\n")
            out_yaml.write(f"            mass: {config.bead_masses[bead_type]}\n")
            out_yaml.write(f"            type_id: {ord(bead_type) - ord('A') + 1}\n")


def read_topology_file(filename: str) -> tuple[list[tuple], list[tuple[int, int]], float]:
    """Reads a topology file and returns chain_description, bond_list and box_size

    Args:
        filename: Path to the topology YAML file

    Returns:
        Tuple of (chain_description, bond_list, box_size) where:
        - chain_description: List of (atom_id, atom_name, residue_id, residue_name, mass)
        - bond_list: List of (atom_i, atom_j)
        - box_size: Box size value
    """
    with open(filename, "r") as in_yaml:
        yaml_data = yaml.safe_load(in_yaml)

    topology = TopologyConfig.from_dict(yaml_data)

    # Generate chain description
    chain_description = []
    atom_id = 1

    # For each chain
    for chain_idx, num_units in enumerate(topology.chain_description.chain_lengths, start=1):
        # For each repeat unit in the chain
        for _ in range(num_units):
            # For each bead in the repeat unit topology
            for bead_type in topology.chain_description.repeat_unit_topology:
                chain_description.append(
                    (
                        atom_id,  # atom_id
                        bead_type,  # atom_name
                        chain_idx,  # residue_id
                        "MOL",  # residue_name
                        topology.polymer.bead_types[bead_type].mass,  # mass
                    )
                )
                atom_id += 1

    # Generate bond list
    bond_list = []

    # For each chain
    for chain_idx, num_units in enumerate(topology.chain_description.chain_lengths):
        chain_start = (
            sum(
                len(topology.chain_description.repeat_unit_topology) * n
                for n in topology.chain_description.chain_lengths[:chain_idx]
            )
            + 1
        )
        chain_length = len(topology.chain_description.repeat_unit_topology) * num_units

        # Connect atoms within the chain
        for j in range(chain_start, chain_start + chain_length - 1):
            bond_list.append((j, j + 1))

    return chain_description, bond_list, topology.box_size


def write_lammps_input(filename, data_file):
    # Get absolute paths
    output_dir = os.path.dirname(os.path.abspath(filename))

    template_dir = os.path.dirname(os.path.abspath(__file__))

    with open(filename, "w+") as f:
        # Open template and render
        with open(os.path.join(template_dir, "lammps_in.tpl"), "r") as template:
            template = Template(template.read())
            rendered = template.substitute(output_dir=output_dir)
            f.write(rendered)


def write_lammps_data(filename, coordinates, chain_description, bond_list, box_size):
    with open(filename, "w+") as out_lmp:
        out_lmp.write("LAMMPS data file\n\n")
        out_lmp.write(f"{len(coordinates)} atoms\n")
        out_lmp.write(f"{len(bond_list)} bonds\n")
        out_lmp.write("\n")
        out_lmp.write("1 atom types\n")
        out_lmp.write("1 bond types\n")
        out_lmp.write("\n")
        out_lmp.write(f"0.0 {box_size} xlo xhi\n")
        out_lmp.write(f"0.0 {box_size} ylo yhi\n")
        out_lmp.write(f"0.0 {box_size} zlo zhi\n")
        out_lmp.write("\n")
        out_lmp.write("Atoms\n\n")
        # Format: atom-ID molecule-ID atom-type x y z
        for i, (atom_id, _, res_id, _) in enumerate(chain_description, start=1):
            x, y, z = coordinates[i - 1]
            out_lmp.write(f"{i} {res_id} 1 {x} {y} {z}\n")  # Changed atom type to always be 1
        out_lmp.write("\n")
        out_lmp.write("Bonds\n\n")
        for i, (atom_i, atom_j) in enumerate(bond_list, start=1):
            out_lmp.write(f"{i} 1 {atom_i} {atom_j}\n")
