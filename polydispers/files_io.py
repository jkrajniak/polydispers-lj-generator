import os

import numpy as np
import yaml


def write_gro_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by gro_writer",
) -> None:
    """
    Write a GRO format file with simplified inputs.

    Args:
        filename: Output .gro filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string
    """
    n_atoms = len(coordinates)

    with open(filename, "w") as f:
        # Write title line
        f.write(f"{title}\n")

        # Write number of atoms
        f.write(f"{n_atoms}\n")

        # Write atom information
        for i, (x, y, z) in enumerate(coordinates, start=1):
            resid = 1
            atomid = i
            line = f"{resid:>5d}{resname:<5s}{atomname:>5s}{atomid:>5d}"
            line += f"{x:8.3f}{y:8.3f}{z:8.3f}"
            f.write(line + "\n")

        # Write box vectors (cubic box)
        f.write(f"{box_size:10.5f}{box_size:10.5f}{box_size:10.5f}\n")


def write_pdb_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by pdb_writer",
) -> None:
    """
    Write a PDB format file with simplified inputs.

    Args:
        filename: Output .pdb filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string

    PDB Format Reference:
    ATOM/HETATM (1-6)    Record name
    atom number (7-11)    Integer
    atom name (13-16)     Atom name
    alt loc (17)          Alternate location indicator
    residue name (18-20)  Residue name
    chain (22)            Chain identifier
    residue number (23-26) Integer
    x (31-38)            Real(8.3) Orthogonal coordinates for X
    y (39-46)            Real(8.3) Orthogonal coordinates for Y
    z (47-54)            Real(8.3) Orthogonal coordinates for Z
    occupancy (55-60)     Real(6.2)
    temp factor (61-66)   Real(6.2)
    segment id (73-76)    Segment identifier
    element (77-78)       Element symbol
    charge (79-80)        Charge
    """
    # Convert nm to Angstroms for PDB format
    coords_ang = coordinates * 10.0
    box_ang = box_size * 10.0
    resid = 1

    with open(filename, "w") as f:
        # Write title
        f.write(f"TITLE     {title}\n")
        f.write("REMARK    Generated by pdb_writer\n")

        # Write crystal structure (box size)
        # Format: CRYST1   50.000   50.000   50.000  90.00  90.00  90.00 P 1           1
        f.write(f"CRYST1{box_ang:9.3f}{box_ang:9.3f}{box_ang:9.3f}  90.00  90.00  90.00 P 1           1\n")

        # Write atom coordinates
        for i, (x, y, z) in enumerate(coords_ang, start=1):
            # Format each field according to PDB specifications
            record = "ATOM  "  # cols 1-6
            serial = f"{i:5d}"  # cols 7-11
            space1 = " "  # col 12
            atom = f"{atomname:<4s}"  # cols 13-16
            alt_loc = " "  # col 17
            res_name = f"{resname:<3s}"  # cols 18-20
            space2 = " "  # col 21
            chain = "A"  # col 22
            res_seq = f"{resid:4d}"  # cols 23-26
            ins_code = " "  # col 27
            space3 = "   "  # cols 28-30
            x_coord = f"{x:8.3f}"  # cols 31-38
            y_coord = f"{y:8.3f}"  # cols 39-46
            z_coord = f"{z:8.3f}"  # cols 47-54
            occupancy = f"{1.00:6.2f}"  # cols 55-60
            temp_factor = f"{0.00:6.2f}"  # cols 61-66
            space4 = "      "  # cols 67-72
            segment = f"{resname:<4s}"  # cols 73-76
            element = f"{atomname:>2s}"  # cols 77-78
            charge = "  "  # cols 79-80

            line = (
                f"{record}{serial}{space1}{atom}{alt_loc}{res_name}"
                f"{space2}{chain}{res_seq}{ins_code}{space3}"
                f"{x_coord}{y_coord}{z_coord}{occupancy}{temp_factor}"
                f"{space4}{segment}{element}{charge}\n"
            )

            f.write(line)

        # Write END record
        f.write("END\n")


def write_packmol_input(
    output_filename: str, filenames: list[str], box_size: float, output_packmol_filename: str, filetype: str = "xyz"
) -> None:
    with open(output_packmol_filename, "w") as f:
        f.write("tolerance 2.0\n")
        f.write(f"filetype {filetype}\n")
        f.write(f"output {output_filename}\n")
        for filename in filenames:
            f.write(
                f"""
structure {filename}
  number 1
  inside box 0 0 0 {box_size} {box_size} {box_size}
  resnumbers 2
end structure
      """
            )


def write_xyz_file(filename: str, coordinates: np.ndarray, atomname: str = "C") -> None:
    with open(filename, "w") as f:
        f.write(f"{len(coordinates)}\n")
        f.write("Generated by xyz_writer\n")
        for i, (x, y, z) in enumerate(coordinates, start=1):
            f.write(f"{atomname} {x} {y} {z}\n")


def write_topology_file(
    filename: str, box_size: float, chain_lengths: list[int], atomname: str = "C", resname: str = "MOL"
) -> None:
    """Generates a topology file for the system"""
    # atom_id, atom_name, residue_id, residue_name
    chain_description = []
    for res_id, chain_length in enumerate(chain_lengths, 1):
        for j in range(chain_length):
            # Atom id is continuous across all chains
            atom_id = sum(chain_lengths[: res_id - 1]) + j + 1
            chain_description.append((atom_id, atomname, res_id, resname))

    bond_list = []
    # atom_i, atom_j
    for res_id, chain_length in enumerate(chain_lengths, 1):
        for j in range(1, chain_length):
            atom_i = sum(chain_lengths[: res_id - 1]) + j
            atom_j = sum(chain_lengths[: res_id - 1]) + j + 1
            bond_list.append((atom_i, atom_j))

    # Write YAML file that will as a value keep CSV values.
    # chain_description:
    #     columns: ["atom_id", "atom_name", "residue_id", "residue_name"]
    #     values: <
    #         1, C, 1, MOL
    #         2, C, 1, MOL
    with open(filename, "w+") as out_yaml:
        out_yaml.write(f"box_size: {box_size}\n")
        out_yaml.write("chain_description:\n")
        out_yaml.write('    columns: ["atom_id", "atom_name", "residue_id", "residue_name"]\n')
        out_yaml.write("    values: |\n")
        for row in chain_description:
            out_yaml.write(f"        {', '.join(map(str, row))}\n")

        out_yaml.write("\n")
        out_yaml.write("bond_list:\n")
        out_yaml.write('    columns: ["atom_i", "atom_j"]\n')
        out_yaml.write("    values: |\n")
        for row in bond_list:
            out_yaml.write(f"        {', '.join(map(str, row))}\n")


def read_topology_file(filename: str) -> tuple[list[tuple[int, str, int, str]], list[tuple[int, int]], float]:
    """Reads a topology file and returns chain_description, bond_list and box_size"""
    chain_description: list[tuple[int, str, int, str]] = []
    bond_list: list[tuple[int, int]] = []

    with open(filename, "r") as in_yaml:
        yaml_data = yaml.safe_load(in_yaml)

    # split yaml_data['chain_description']['values'] into a list of tuples
    chain_description = [
        tuple(map(str.strip, row.split(",")))
        for row in yaml_data["chain_description"]["values"].split("\n")
        if row.strip()
    ]

    # split yaml_data['bond_list']['values'] into a list of tuples
    bond_list = [
        tuple(map(str.strip, row.split(","))) for row in yaml_data["bond_list"]["values"].split("\n") if row.strip()
    ]

    return chain_description, bond_list, yaml_data["box_size"]


def write_lammps_input(filename, data_file):
    # Get absolute paths
    abs_data_file = os.path.abspath(data_file)
    output_dir = os.path.dirname(os.path.abspath(filename))

    with open(filename, "w+") as f:
        f.write(
            """# LAMMPS input script for polymer simulation
units           lj
atom_style      molecular
boundary        p p p

# Set special bonds for FENE potential
special_bonds   lj 0.0 1.0 1.0

read_data       {}

# Set mass for atom type 1
mass            1 1.0

# Initialize velocities at T=1.0
velocity        all create 1.0 12345 dist gaussian

# First minimize to fix any bad contacts or stretched bonds
minimize        1.0e-4 1.0e-6 1000 10000

# Reset time
reset_timestep  0

# Define pair and bond styles
pair_style      lj/cut 2.5
pair_coeff      1 1 1.0 1.0 2.5

bond_style      fene
bond_coeff      1 30.0 1.5 1.0 1.0

# Compute energies
compute         pe all pe/atom
compute         pair all pair lj/cut
compute         ebond all pe/atom bond
compute         epair all pe/atom pair
compute         total_pe all reduce sum c_pe
compute         bond_pe all reduce sum c_ebond
compute         pair_pe all reduce sum c_epair

# Output settings with reduced precision
thermo          1000
thermo_style    custom step temp press density c_total_pe vol lx ly lz
thermo_modify   format float %.3f
thermo_modify   format 3 %.6f  # special format for density

# Save detailed thermo data to file with reduced precision
fix             thermo all print 1000 &
                "%d %.3f %.3f %.6f %.2f %.2f %.2f" &
                file {}/thermo.dat &
                title "# Step Temp Press Density TotalPE BondE PairE" &
                screen no

# Trajectory output with reduced precision
dump            1 all custom 1000 {}/traj.lammpstrj id type mol x y z
dump_modify     1 format float %.4f

# -------- NPT Equilibration with Berendsen --------
timestep        0.005  # Small timestep for stability

# Berendsen thermostat and barostat (separately)
fix             bthermo all temp/berendsen 5.0 5.0 500.0
fix             bpress all press/berendsen iso 1.0 1.0 1000.0

# Run NPT equilibration
run             50000

# Remove Berendsen fixes
# unfix           bthermo
unfix           bpress

# -------- NVT Equilibration --------
# timestep        0.005
# fix             nvt all nvt temp 5.0 5.0 500.0
run             500000
""".format(
                abs_data_file, output_dir, output_dir
            )
        )


def write_lammps_data(filename, coordinates, chain_description, bond_list, box_size):
    with open(filename, "w+") as out_lmp:
        out_lmp.write("LAMMPS data file\n\n")
        out_lmp.write(f"{len(coordinates)} atoms\n")
        out_lmp.write(f"{len(bond_list)} bonds\n")
        out_lmp.write("\n")
        out_lmp.write("1 atom types\n")
        out_lmp.write("1 bond types\n")
        out_lmp.write("\n")
        out_lmp.write(f"0.0 {box_size} xlo xhi\n")
        out_lmp.write(f"0.0 {box_size} ylo yhi\n")
        out_lmp.write(f"0.0 {box_size} zlo zhi\n")
        out_lmp.write("\n")
        out_lmp.write("Atoms\n\n")
        # Format: atom-ID molecule-ID atom-type x y z
        for i, (atom_id, _, res_id, _) in enumerate(chain_description, start=1):
            x, y, z = coordinates[i - 1]
            out_lmp.write(f"{i} {res_id} 1 {x} {y} {z}\n")  # Changed atom type to always be 1
        out_lmp.write("\n")
        out_lmp.write("Bonds\n\n")
        for i, (atom_i, atom_j) in enumerate(bond_list, start=1):
            out_lmp.write(f"{i} 1 {atom_i} {atom_j}\n")
