
import numpy as np


def write_gro_file(filename: str, 
                   coordinates: np.ndarray,
                   box_size: float,
                   atomname: str = "C",
                   resname: str = "MOL",
                   title: str = "Generated by gro_writer") -> None:
    """
    Write a GRO format file with simplified inputs.
    
    Args:
        filename: Output .gro filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string
    """
    n_atoms = len(coordinates)
    
    with open(filename, 'w') as f:
        # Write title line
        f.write(f"{title}\n")
        
        # Write number of atoms
        f.write(f"{n_atoms}\n")
        
        # Write atom information
        for i, (x, y, z) in enumerate(coordinates, start=1):
            resid = 1
            atomid = i
            line = f"{resid:>5d}{resname:<5s}{atomname:>5s}{atomid:>5d}"
            line += f"{x:8.3f}{y:8.3f}{z:8.3f}"
            f.write(line + '\n')
        
        # Write box vectors (cubic box)
        f.write(f"{box_size:10.5f}{box_size:10.5f}{box_size:10.5f}\n")


def write_pdb_file(filename: str,
                   coordinates: np.ndarray,
                   box_size: float,
                   atomname: str = "C",
                   resname: str = "MOL",
                   title: str = "Generated by pdb_writer") -> None:
    """
    Write a PDB format file with simplified inputs.
    
    Args:
        filename: Output .pdb filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string
  
    PDB Format Reference:
    ATOM/HETATM (1-6)    Record name
    atom number (7-11)    Integer
    atom name (13-16)     Atom name
    alt loc (17)          Alternate location indicator
    residue name (18-20)  Residue name
    chain (22)            Chain identifier
    residue number (23-26) Integer
    x (31-38)            Real(8.3) Orthogonal coordinates for X
    y (39-46)            Real(8.3) Orthogonal coordinates for Y
    z (47-54)            Real(8.3) Orthogonal coordinates for Z
    occupancy (55-60)     Real(6.2)
    temp factor (61-66)   Real(6.2)
    segment id (73-76)    Segment identifier
    element (77-78)       Element symbol
    charge (79-80)        Charge
    """
    # Convert nm to Angstroms for PDB format
    coords_ang = coordinates * 10.0
    box_ang = box_size * 10.0
    resid = 1
    
    with open(filename, 'w') as f:
        # Write title
        f.write(f"TITLE     {title}\n")
        f.write(f"REMARK    Generated by pdb_writer\n")
        
        # Write crystal structure (box size)
        # Format: CRYST1   50.000   50.000   50.000  90.00  90.00  90.00 P 1           1
        f.write(f"CRYST1{box_ang:9.3f}{box_ang:9.3f}{box_ang:9.3f}  90.00  90.00  90.00 P 1           1\n")
        
        # Write atom coordinates
        for i, (x, y, z) in enumerate(coords_ang, start=1):
            # Format each field according to PDB specifications
            record = "ATOM  "                    # cols 1-6
            serial = f"{i:5d}"                   # cols 7-11
            space1 = " "                         # col 12
            atom = f"{atomname:<4s}"             # cols 13-16
            alt_loc = " "                        # col 17
            res_name = f"{resname:<3s}"          # cols 18-20
            space2 = " "                         # col 21
            chain = "A"                          # col 22
            res_seq = f"{resid:4d}"             # cols 23-26
            ins_code = " "                       # col 27
            space3 = "   "                       # cols 28-30
            x_coord = f"{x:8.3f}"               # cols 31-38
            y_coord = f"{y:8.3f}"               # cols 39-46
            z_coord = f"{z:8.3f}"               # cols 47-54
            occupancy = f"{1.00:6.2f}"          # cols 55-60
            temp_factor = f"{0.00:6.2f}"        # cols 61-66
            space4 = "      "                    # cols 67-72
            segment = f"{resname:<4s}"           # cols 73-76
            element = f"{atomname:>2s}"          # cols 77-78
            charge = "  "                        # cols 79-80
            
            line = (f"{record}{serial}{space1}{atom}{alt_loc}{res_name}"
                   f"{space2}{chain}{res_seq}{ins_code}{space3}"
                   f"{x_coord}{y_coord}{z_coord}{occupancy}{temp_factor}"
                   f"{space4}{segment}{element}{charge}\n")
            
            f.write(line)
        
        # Write END record
        f.write("END\n")


def write_packmol_input(output_filename: str,
                        filenames: list[str],
                        box_size: float,
                        filetype: str = "pdb") -> None:
  with open("packmol_input.txt", "w") as f:
    f.write("tolerance 2.0\n")
    f.write(f"filetype {filetype}\n")
    f.write(f"output {output_filename}\n")
    for filename in filenames:
      f.write(f"""
structure {filename}
  number 1
  inside box 0 0 0 {box_size} {box_size} {box_size}
  resnumbers 2
end structure
      """)
      

def write_xyz_file(filename: str,
                   coordinates: np.ndarray,
                   atomname: str = "C") -> None:
  with open(filename, "w") as f:
    f.write(f"{len(coordinates)}\n")
    f.write(f"Generated by xyz_writer\n")
    for i, (x, y, z) in enumerate(coordinates, start=1):
      f.write(f"{atomname} {x} {y} {z}\n")


def write_topology_file(filename: str,
                        chain_lengths: list[int],
                        atomname: str = "C",
                        resname: str = "MOL") -> None:
    """Generates a topology file for the system"""
    # atom_id, atom_name, residue_id, residue_name
    chain_description = []
    for res_id, chain_length in enumerate(chain_lengths, 1):
        for j in range(chain_length):
            # Atom id is continuous across all chains
            atom_id = sum(chain_lengths[:res_id-1]) + j + 1
            chain_description.append((atom_id, atomname, res_id, resname))

    bond_list = []
    # atom_i, atom_j
    for res_id, chain_length in enumerate(chain_lengths, 1):
        for j in range(1, chain_length):
            atom_i = sum(chain_lengths[:res_id-1]) + j
            atom_j = sum(chain_lengths[:res_id-1]) + j + 1
            bond_list.append((atom_i, atom_j))

    # Write YAML file that will as a value keep CSV values.
    # chain_description:
    #     columns: ["atom_id", "atom_name", "residue_id", "residue_name"]
    #     values: <
    #         1, C, 1, MOL
    #         2, C, 1, MOL
    with open(filename, 'w+') as out_yaml:
        out_yaml.write("chain_description:\n")
        out_yaml.write("    columns: [\"atom_id\", \"atom_name\", \"residue_id\", \"residue_name\"]\n")
        out_yaml.write("    values: |\n")
        for row in chain_description:
            out_yaml.write(f"        {', '.join(map(str, row))}\n")

        out_yaml.write("\n")
        out_yaml.write("bond_list:\n")
        out_yaml.write("    columns: [\"atom_i\", \"atom_j\"]\n")
        out_yaml.write("    values: |\n")
        for row in bond_list:
            out_yaml.write(f"        {', '.join(map(str, row))}\n")

def read_topology_file(filename: str) -> tuple[list[tuple[int, str, int, str]], list[tuple[int, int]]]:
    """Reads a topology file and returns chain_description and bond_list"""
    chain_description: list[tuple[int, str, int, str]] = []
    bond_list: list[tuple[int, int]] = []
    with open(filename, 'r') as f:
        lines = f.readlines()
        for i, line in enumerate(lines):
            if line.startswith("chain_description:"):
                for j in range(i+2, len(lines)):
                    if lines[j].startswith("bond_list:"):
                        break
                    values = lines[j].strip().split(", ")
                    chain_description.append(tuple(map(eval, values)))
            elif line.startswith("bond_list:"):
                for j in range(i+2, len(lines)):
                    values = lines[j].strip().split(", ")
                    bond_list.append(tuple(map(eval, values)))

    return chain_description, bond_list
